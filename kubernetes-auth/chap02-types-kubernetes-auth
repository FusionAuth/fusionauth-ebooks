# Auth Layers in Your Cluster

When considering auth inside your Kubernetes cluster, it's good to think of three different layers.

IMAGE

Each of these layers has different needs and requirements and implementation choices.

The first is the infrastructure layer. The second is the service-to-service layer. And the third is the request/response layer.

Let's look at each in turn.

## Infrastructure

This is the control plane layer. This determines who can do what to your Kubernetes cluster. This cincludes such tasks as:

* updating a deployment
* deleting a node
* adding a secret

This is the kind of authentication discussed in [the Kubernetes documentation](https://kubernetes.io/docs/reference/access-authn-authz/authentication/). As outlined there:

> API requests are tied to either a normal user or a service account, or are treated as anonymous requests. This means every process inside or outside the cluster, from a human user typing kubectl on a workstation, to kubelets on nodes, to members of the control plane, must authenticate when making requests to the API server, or be treated as an anonymous user.

So any API request that needs to read from, add to, or modify Kubernetes configuration must be authenticated (unless the request is available to anonymous users).

The Kubernetes documentation outlines all supported options for both service accounts and user accounts, so this article won't cover them in detail.

A wide variety of options are supported, including

* Custom headers using an authenticating proxy
* OIDC tokens generated by an external IdP
* Client certificates
* Webhooks which receive a token and can validate access

There's also an impersonation option, which allows users to "take on" the identity of other users to test access.

Once these users are authenticated information about them, such as username, group, and resources requested is made available to [Kubernetes authorizers](https://kubernetes.io/docs/reference/access-authn-authz/authorization/). These are again well documented, but support the following methods of determining access:

* ABAC: policies are combined and evaluated
* RBAC: roles associated with the user control
* Webhooks, which fire to a known destination; the response is what decides access

If relying on external sources to determine your access, such as an OIDC server or webhooks, ensure you have an escape hatch which doesn't depend on that external source to modify the configuration of your cluster. 

## Application Auth

When you have containers running in pods on Kubernetes, there are levels of authentication entirely above the infrastructure level outlined in the previous section. 

IMAGE

For instance, if you are running the todo application diagrammed above, you must ensure that Alice has access to Alice's todos and Bob has access to Bob's todos. But this authentication and authorization decision making happens at the level of the todos application and has nothing to do with the nodes and Kubernetes API access.

There are two common types of authentication at the application level:

* mutual TLS
* token based authentication

## Mutual TLS

Mutual TLS is based on the idea of client certificates. Suppose the reminders service needs to request information from the todos service to send a notice for every user with a todo due date in the next 24 hours. You'll want to ensure two things:

* that the reminders service can access the data it needs
* that the todos service isn't open to any unauthorized access

Because it is the reminders service that is making the request, mutual TLS is a good solution. Each service can have a certificate and they can mutually verify them.

This can be done manually, but a far simpler solution is to use a service mesh such as Istio or Linkerd.

If you are using Istio, you can enable strict mutual TLS authentication using this configuration:

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: "default"
spec:
  mtls:
    mode: STRICT
```

You'd apply it using a command like this:

```shell
kubectl apply -n istio-system -f - <<EOF
```

You can read more about [mutual TLS authentication in Istio](https://istio.io/latest/docs/tasks/security/authentication/mtls-migration/).

Since every service in Istio is transparently associated with a client certificate, once mutual TLS is enabled, you can enforce authorization rules. 

In the application above, one such rule is that that the reminder service can call the todos service, but not the reverse. Here's an example:

```yaml
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: "todos-viewer-allow"
  namespace: default
spec:
  selector:
    matchLabels:
      app: todos
  action: ALLOW
  rules:
  - from:
    - source:
        principals: ["cluster.local/ns/default/sa/reminders"]
    to:
    - operation:
        methods: ["GET"]
```
TODO test

```yaml
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: "todos-viewer-allow"
  namespace: default
spec:
  selector:
    matchLabels:
      app: reminders
  action: DENY
  rules:
  - from:
    - source:
        principals: ["cluster.local/ns/default/sa/todos"]
```

This setup will enforce service level separation.

Again, you don't have to use a service mesh for this kind of authentication. You could provide every service with a unique static identifier which was rotated regularly (an API key) and implement the exact same type of service to service authentication. You could also use the OAuth client credentials grant and treat each service or endpoint as a separate resource.

There are many ways to solve this issue, but at the root, each recognizes the service as the requesting entity.

However, what happens when user is involved? Let's look at that next.

## Auth for Requests

When a request for a todo comes in, it is associated, as mentioned above, with a particular user such as Alice or Bob. This is an additional layer of authentication and authorization data that client certificates or the other methods mentioned previously can't help with. In this case you want to reach for tokens.

Tokens are typically provided by the requesting client and are the result of something like an OAuth grant. They are very often JSON Web Tokens and contain a payload which looks like this:

```json
{ 
  "aud": "85a03867-dccf-4882-adde-1a79aeec50df",
  "exp": 1644884185,
  "iat": 1644880585,
  "iss": "acme.com",
  "sub": "00000000-0000-0000-0000-000000000001",
  "jti": "3dd6434d-79a9-4d15-98b5-7b51dbb2cd31",
  "authenticationType": "PASSWORD",
  "email": "admin@fusionauth.io",
  "email_verified": true,
  "applicationId": "85a03867-dccf-4882-adde-1a79aeec50df",
  "roles": [
    "ceo"
  ]
}
```

Again, depending on your implementation, you may be able to configure a service mesh to examine claims in the token, such as the `roles` claim. You can also use an ambassador container to examine these claims, or do so inside your microservices. These options are discussed in more detail in [TODO link to tokens for k8s post](#tokens-kubernetes).

However, there may be cases where you want to modify a token that comes in from a request and specify that a request is coming from both a given service and a user request. For example, in the todos application, a user might be able to share a todo. Alice might share a todo with Bob. In this case, when Bob requests his shared todos, the shares microservice will need to call the todos service but make sure it is clear that it is doing so on behalf of Bob, not itself. 

This can either be done via a [standardized OAuth grant](https://datatracker.ietf.org/doc/html/rfc8693/), if your identity provider supports it, or by otherwise passing the identity of the requester through via a token. 

## Summary

This chapter covered three different layers of Kubernetes authentication:

* the infrastructure layer
* the service-to-service layer
* the request/response layer

Each of these is important in ensuring that your application is appropriately secured.
